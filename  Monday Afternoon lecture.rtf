{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28300\viewh17220\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 What is your relationship with technology?\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\qc\partightenfactor0

\fs48 \cf0 Promises:
\fs24 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
What is it?\
A syntax for working with async Javascript functions\
\
Why?\
Code readability/maintainability\
\
Callback: passing functions into function\
\
Promises: \
Helpful when we have to deal with multiple async functions\
\
Metaphor for promises:\
Can I borrow that book, yeah I think it\'92s at home but I\'92ll give it to you.\
\
Promises have 2 states:\
Fulfilled (ERROR OR SUCCESS)\
Unfulfilled\
\

\fs36 \
Consuming promises\
Create a function that returns a promise (using Knex)\
\

\fs28 Read file\
Append file\
Read file\
\
getShourceContents()\
\
Is our target\
\
getSourceContents()\
.then(appendToDestination) 
\i this is a promise\
.then(showDestination)\

\i0 .catch (showError) 
\i the promise is resolved but rejected
\i0\fs36 \
\
\

\fs28 Return new Promise((resolve, reject) => \{\
fs.readfile(source, \'91utf8\'92, (err, contents) => \{\
If (err) return reject(err)\
Resolve(contents)
\fs36 \
\
\
> If we run into a sad path, we\'92re going to reject.\
\
Resolve == then and reject == catch\
\
Promises get the data, returns the function and passes it into the input of the next function.\
\
Happy path = then\
Sad path = catch\
\
\
Promise resource: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\
\
\
\
\
\
\

\fs24 \
\
\
}